<HTML><HEAD>

<TITLE>Leonardo Boselli's JROBOTS</TITLE>

<META NAME="KeyWords" CONTENT="virtual, reality, artificial, intelligence, physics, systems, java, applets, on-line, games"></HEAD>

<BODY Bgcolor="black" Text=#ffffff Link=#ffc00 VLink=#ffc00 ALink=#f1e2f3 
      topmargin=0 leftmargin=0 rightmargin=0 bottommargin=0>


<!--------------- HEADER ------------------------->

<TABLE border=0 cellPadding=0 cellSpacing=0 width="100%">
  <TBODY>
  <TR align=left width="100%">
     <TD align=left><img border=0 
      src="gfx/titlebg_1.jpg"></td>
    <TD align=right width="100%" valign=middle background="gfx/titlebg_2.jpg"> </TD></TR></TBODY></TABLE>
<table border=1 bordercolor="black" cellpadding=0 cellspacing=0 bgcolor=78398D width=100%><tr><td>
<font color=white size=2 face= verdana,arial><center>Multi-User, Time-Sharing, Real-Time Java Algorithms Challenge</center></font>
</td></tr></table>

<!--------------- Main Table --------------------->

  <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=4 HEIGHT=100% WIDTH=100% bgcolor=695246>
  <TR><TD VALIGN=TOP ALIGN=CENTER>

<!---------------- Menu Table -------------------->

  <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=6 WIDTH=100% height=100%>
  <TR><TD VALIGN=TOP ALIGN=center WIDTH=150 valign=top height=100%>
    
    <TABLE BORDER=0 CELLPADDING=0 WIDTH=150 height=100%>
<!---------- Start of menu ------------>
			<TABLE border=0 cellPadding=0 cellSpacing=0 width="100%" height=100%>
			 <TR valign=bottom><td valign=bottom>
  			  <table cellpadding=0 border=0 cellspacing=0><tr valign=top><td valign=top><img
                    src="gfx/menu_top.gif" alt="" width=150></td></tr>
	    		<tr><td background="gfx/menu_bk.gif">&nbsp;</td></tr></table>
			 </td</tr> 
			 <tr height=100%><td background="gfx/menu_bk.gif" valign=top>
                   <CENTER><FONT face="Arial, Helvetica, Geneva" size=2></center>


&nbsp;&bull;&nbsp;
<A HREF="jjr_info.html">Info</A><br>

&nbsp;&bull;&nbsp;
<A HREF="jjr_faq.html">FAQ</A><br>

&nbsp;&bull;&nbsp;
<A HREF="jjr_tutorials.html">Tutorials</A><br>

&nbsp;&bull;&nbsp;
<A HREF="http://www.onelist.com/group/javajousters">Mailing List</A><br>

<br><br>

&nbsp;&bull;&nbsp;
<A HREF="http://jrobots.sourceforge.net/accounts.shtml">Accounts</A><br>

&nbsp;&bull;&nbsp;
<A HREF="http://jrobots.sourceforge.net/uploads.shtml">Uploads</A><br>

&nbsp;&bull;&nbsp;
<A HREF="http://jrobots.sourceforge.net/downloads.shtml">Downloads</A><br>

<br><br>

&nbsp;&bull;&nbsp;
<A HREF="jjr_match.html"><b>Battle Applet</b></A><br>

&nbsp;&bull;&nbsp;
<A HREF="http://jrobots.sourceforge.net/jjr_contests.shtml">Challenges</A><br>
<br><br><center>
<a href="http://www.jars.com/classes/jresout.cgi?resource=6808"><img src="jars_75.gif" alt="JARS Top 25%" align=center border=0></a><br></center>

</FONT>
   
</td></tr>
			<tr height=100%><td height=100% background="gfx/menu_bk.gif"><br><br>
                  <img src="gfx/menu_bk.gif" alt="" height=100% width=150></td></tr>
			<tr valign=top><td valign=top><img src="gfx/menu_bot.gif" alt="" width=150></td>
                  </tr></table>
<!---------- End of menu --------->

  </TD>

<!------------------ Text Table ------------------>


<TD VALIGN=TOP ALIGN=CENTER>

<TABLE BORDER=1 BGCOLOR="#1F0635" border color="black" cellpadding=8 cellspacing=0><TR><TD>

<!--------------------------------------------------->
<!-------- Changes should be done here only --------->
<!--------------------------------------------------->


<FONT FACE="verdana,arial" SIZE=-1>

<A NAME="index">
<P ALIGN=CENTER><FONT COLOR=yellow SIZE=+1>Jrobots Tutorials</FONT><br><center><font size=-1><A HREF="jjr_tutorials.html">[English]</a>&nbsp<A HREF="jjr_tutorialsIta.html">[Italiano]</a>&nbsp;[Español]</font></center>

<hr>
      <OL>
        <LI><a href="#aiming">Técnicas para apuntar</a> 
        <LI><a href="#Platoon">La construcción de Platoon</a> 
        <LI><a href="#Phalanax y Stinger">La construcción de Phalanx y Stinger
        </a> </LI></OL>
      <HR>
      <a name="aiming"></a><FONT color=yellow><B>Técnicas para apuntar </B> - <FONT 
      size=-1>Autor: <A href="mailto:boselli@uno.it">Leonardo 
      Boselli</A></FONT></FONT> 
      <P>Las limitaciones de los robots más simples son claras: usan el radar 
      para localizar el enemigo y disparan un misil a dicha ubicación. 
      Generalmente fallan en su intento de impactar el objetivo porque el 
      enemigo se ha movido mientras el misil viaja hasta el punto donde debe 
      explotar.<P>Para obtener mejores resultados, un robot debe estimar la 
    velocidad de su enemigo y luego disparar un misil a la posición futura que 
    éste tendrá al momento de explotar. El siguiente algoritmo es usado por <B>Phalanx</B> 
    y 
      <B>Stinger</B>, y puede ser dividido en cuatro partes: 
      <OL>
        <LI><B>Estimación de velocidad</B><BR>Para calcular la velocidad del 
        enemigo, un robot debe usar el radar para identificar la ubicación del 
        enemigo en diferentes momentos. Recuerde que las principales funciones 
        (como el scan()) retornan valores enteros, lo que obliga a realizar 
        rastreos cada cierto tiempo de tal manera de mejorar la precisión. Esta 
        es la parte difícil del algoritmo y la dejaré al lector como ejercicio 
        :)<p>&nbsp;</p>
        <P></P>
        <LI><B>Cálculo del tiempo de vuelo</B><BR>Cuando ya tienes la ubicación 
        y la velocidad del enemigo, el entrenamiento del cañón es sencillo. 
        <BR>Antes que nada, el vuelo del misil es independiente de la velocidad 
        del robot que lo dispara (esto es explicado en
        <a href="jjr_infoSpa.html#missiles">Info 
        section</a>). El misil siempre vuela a 300&nbsp;m/s, por lo que tenemos 
        que estimar el punto donde un misil volando a dicha velocidad 
        interceptará al enemigo en movimiento. 
        <P>Puedes encontrar la fórmula exacta para calcular el tiempo de vuelo 
        de esta manera:<P>Digamos que <B>P</B> (usando notación vectorial) es el 
        punto desconocido en el que el misil interceptará al enemigo. <B>R</B> 
        es la ubicación del robot que realiza el disparo. 
        <B>T</B> la ubicación inicial del objetivo y <B>V</B> su velocidad. 
        <BR>El objetivo alcanzará el punto <B>P</B> en <I>t</I> segundos, 
        de acuerdo con la fórmula:<P><B>P</B>&nbsp;=&nbsp;<B>T</B>&nbsp;+&nbsp;<B>V</B>&nbsp;<I>t</I></P>
        El misil recorrerá 300.<i>t</i> metros para alcanzar el punto <B>P</B>, 
        que es igual a la distancia de <B>P</B> a <B>R</B><P>(<B>P</B>&nbsp;-&nbsp;<B>R</B>)<SUP>2</SUP>&nbsp;=&nbsp;(300&nbsp;<I>t</I>)<SUP>2</SUP></P>
        Ahora tenemos tres ecuaciones que podemos usar para encontrar el tiempo 
        de vuelo 
        <I>t</I>.<BR>Después de algunos cálculos algebraicos obtenemos:<P><I>t</I>&nbsp;=&nbsp;(&nbsp;sqrt(300<SUP>2</SUP>&nbsp;<B>D</B><SUP>2</SUP>&nbsp;-&nbsp;(<B>D</B>x<B>V</B>)<SUP>2</SUP>)&nbsp;+&nbsp;<B>D</B>·<B>V</B>&nbsp;)&nbsp;/&nbsp;(300<SUP>2</SUP>&nbsp;-&nbsp;<B>V</B><SUP>2</SUP>)</P>
        donde 
        <B>D</B>&nbsp;=&nbsp;<B>T</B>&nbsp;-&nbsp;<B>R</B>, "x" es el producto 
        vectorial de dos vectores y "·" su producto escalar. 
        <P>Si no estás familiarizado con la notación vectorial, quizás es más 
        claro:<P>D<SUB>x</SUB>&nbsp;=&nbsp;T<SUB>x</SUB>&nbsp;-&nbsp;R<SUB>x</SUB> 
        <BR>D<SUB>y</SUB>&nbsp;=&nbsp;T<SUB>y</SUB>&nbsp;-&nbsp;R<SUB>y</SUB> 
        <BR><I>t</I>&nbsp;=&nbsp;(&nbsp;sqrt(300<SUP>2</SUP>&nbsp;(D<SUB>x</SUB><SUP>2</SUP>&nbsp;+&nbsp;D<SUB>y</SUB><SUP>2</SUP>)&nbsp;-&nbsp;(D<SUB>x</SUB>V<SUB>y</SUB>&nbsp;-&nbsp;D<SUB>y</SUB>V<SUB>x</SUB>)<SUP>2</SUP>)&nbsp;+&nbsp;(D<SUB>x</SUB>V<SUB>x</SUB>&nbsp;+&nbsp;D<SUB>y</SUB>V<SUB>y</SUB>)&nbsp;)&nbsp;/&nbsp;(300<SUP>2</SUP>&nbsp;-&nbsp;(V<SUB>x</SUB><SUP>2</SUP>&nbsp;+&nbsp;V<SUB>y</SUB><SUP>2</SUP>)&nbsp;) 
        </P>
        <LI><B>Cálculo del nuevo objetivo</B><BR>Para calcular la ubicación del 
        objetivo luego del tiempo de vuelo del misil, simplemente debes 
        sustituir <I>t</I> en las ecuaciones de movimiento del enemigo por:<P><B>P</B>&nbsp;=&nbsp;<B>T</B>&nbsp;+&nbsp;<B>V</B>&nbsp;<I>t</I></P>
        <p>esto es:</p>
        <P>P<SUB>x</SUB>&nbsp;=&nbsp;T<SUB>x</SUB>&nbsp;+&nbsp;V<SUB>x</SUB>&nbsp;<I>t</I> 
        <BR>P<SUB>y</SUB>&nbsp;=&nbsp;T<SUB>y</SUB>&nbsp;+&nbsp;V<SUB>y</SUB>&nbsp;<I>t</I></P>
        <LI><B>Entrenamiento del disparo</B><BR>Finalmente queda una tarea 
        trivial: debes calcular los argumentos de la función <I>cannon()</I> (ángulo 
        y distancia) usando P<SUB>x</SUB>, P<SUB>y</SUB> y las coordenadas de tu 
        robot. </LI></OL><B>Eso es todo!</B> Por preguntas o comentarios, envía 
    un <A 
      href="mailto:boselli@uno.it">email</A>. 
      <HR>
      <P><FONT color=yellow><a href="mailto:boselli@uno.it" name="Platoon"><B>Jrobot: Platoon</B> - <FONT size=-1>Autor: Leonardo Boselli</FONT></a></FONT><a href="mailto:boselli@uno.it" name="Platoon">
      </a> 
      <P>Estos son lo secretos de <B>Platoon</B>, el cual fue mi primer 
      <B>Jrobot</B>. Esta guía puede ser útil para aprender algunos trucos sobre 
      los combates con 
      <B>Jrobots</B>. Este robot es muy simple y funciona mejor en el modo de 
      equipos (Team). 
      <P>Por más información sobre <B>Jrobots</B> ver la
      <a href="jjr_infoSpa.html">sección de 
      información</a>.<BR>Si deseas escribir un manual sobre tu propio robot, 
      envíalo por <A 
      href="mailto:boselli@uno.it?subject=Jrobots Tutorials&amp;body=The name of my Jrobot is...">email</A>. 
      <P>Veamos el código fuente: 
      <P><PRE>public class __Platoon_ extends JJRobot {
/*
</PRE>El nombre de cada robot debe comenzar con 2 underscores y terminar con 1. 
    Solo caracteres alfanuméricos son permitidos en el nombre. Tu clase debe ser 
    una extensión de la clase <I>JJRobot</I>.<PRE>*/
private static int count;
/*
</PRE>La variable contendrá la cantidad de robots amigos involucrados en el 
    combate<PRE>*/
private static int[] cornerX = {50,950,950,50};
private static int[] cornerY = {50,50,950,950};
/*
</PRE>Estos arreglos contienen las coordenadas de las esquinas que usará el 
    robot. <PRE>*/
private static int targetX = 500;
private static int targetY = 500;
/*
</PRE>Coordenadas del último enemigo encontrado<PRE>*/
private static int locX[] = new int[8];
private static int locY[] = new int[8];
/*
</PRE>Ubicaciones de los robots amigos<PRE>*/
private static int corner1;
/*
</PRE>Selección de la primer esquina<PRE>*/
private int nCorner;
private int scan;
private int id;

void main() {
  if((id = id()) == 0) {
    count = 1;
    corner1 = rand(4);
  } else {
    count = id+1;
  }
/*
</PRE>El último bloque <i>if</i> cuenta los robots amigos y inicializa las 
    variables estáticas cuando el primer robot es creado. El método <I>id()</I> 
    retorna un número que identifica cada robot según sus orden de creación.<PRE>*/
  nCorner = corner1;
  int dx = cornerX[nCorner]-(locX[id]=loc_x());
  int dy = cornerY[nCorner]-(locY[id]=loc_y());
  int angle;
  if(dx == 0) {
    angle = dy &gt; 0? 90: 270;
  } else {
    angle = atan(dy*100000/dx);
  }
  if(dx &lt; 0) angle += 180;
  drive(angle,100);
/*
</PRE>Los robots comienzan el camino hacia la esquina seleccionada<PRE>*/
  switch(nCorner) {
    default:
    case 0: while(locX[id] &gt; 150 || locY[id] &gt; 150) fire2(); break;
    case 1: while(locX[id] &lt; 850 || locY[id] &gt; 150) fire2(); break;
    case 2: while(locX[id] &lt; 850 || locY[id] &lt; 850) fire2(); break;
    case 3: while(locX[id] &gt; 150 || locY[id] &lt; 850) fire2(); break;
  }
/*
</PRE>En este bloque <I>switch</I> el robot dispara misiles mientras llega a la 
    esquina<PRE>*/
  do {
    drive(0,0);
    while(speed() &gt;= 50) fire1();
/*
</PRE>El robot dispara mientras espera frenar hasta el 50% de velocidad. Luego... <PRE>*/
    if(++nCorner == 4) nCorner = 0;
    dx = cornerX[nCorner]-loc_x();
    dy = cornerY[nCorner]-loc_y();
    if(dx == 0) {
      angle = dy &gt; 0? 90: 270;
    } else {
      angle = atan(dy*100000/dx);
    }
    if(dx &lt; 0) angle += 180;
    drive(angle,100);
/*
</PRE>... el robot elige la próxima esquina y ... <PRE>*/
    switch(nCorner) {
      default:
      case 0: while(locY[id] &gt; 150) fire1(); break;
      case 1: while(locX[id] &lt; 850) fire1(); break;
      case 2: while(locY[id] &lt; 850) fire1(); break;
      case 3: while(locX[id] &gt; 150) fire1(); break;
/*
</PRE>... dispara misiles esperando llegar a dicha esquina<PRE>*/
    }
  } while(true);
}
private void fire1() {
/*
</PRE>En este método el robot escanea el lado opuesto a la pared<PRE>*/
  switch(nCorner) {
    default:
    case 0: if(++scan &gt; 470 || scan &lt; 240) scan = 250; break;
    case 1: if(++scan &gt; 200 || scan &lt; -30) scan = -20; break;
    case 2: if(++scan &gt; 290 || scan &lt;  60) scan = 70; break;
    case 3: if(++scan &gt; 380 || scan &lt; 150) scan = 160; break;
  }
  fire();
}

private void fire2() {
/*
</PRE>En este método el robot escanea todo a su alrededor<PRE>*/
  if(++scan &gt; 360) scan = 0;
  fire();
}

private void fire() {
  locX[id] = loc_x();
  locY[id] = loc_y();
/*
</PRE>El robot actualiza su posición<PRE>*/
  int range;
  if((range = scan(scan,1)) &gt; 40 &amp;&amp; range &lt;= 740) {
/*
</PRE>
    <p>El radar detecta un robot en una rango de distancia conveniente</p>
    <PRE>*/
    if (count &gt; 1) {
/*
</PRE>El robot no está solo (tiene amigos)<PRE>*/
      boolean shot = true;
      int shotX = locX[id]+range*cos(scan)/100000;
      int shotY = locY[id]+range*sin(scan)/100000;
      for(int ct = 0; ct &lt; count; ct++) {
/*
</PRE>Es el robot encontrado un enemigo?<PRE>*/
        if(ct != id) {
          int dx = shotX-locX[ct];
          int dy = shotY-locY[ct];
          if(dx*dx+dy*dy &lt; 1600) {
            shot = false;
            break;
          }
        }
      }
      if(shot) {
/*
</PRE>Es un enemigo! Dispara e informa a sus amigos sobre el enemigo encontrado<PRE>*/
        targetX = shotX;
        targetY = shotY;
        cannon(scan,range);
        scan -= 10;
/*
</PRE>Gira el radar un poco hacia atrás<PRE>*/
      } else {
/*
</PRE>Es un amigo! Disparar al último enemigo encontrado en su lugar<PRE>*/
        int dx = targetX-locX[id];
        int dy = targetY-locY[id];
        int dist2 = dx*dx+dy*dy;
        if(dist2 &gt; 1600 &amp;&amp; dist2 &lt;= 547600) {
          int angle;
          if(dx == 0) {
            angle = dy &gt; 0? 90: 270;
          } else {
            angle = atan(dy*100000/dx);
            if(dx &lt; 0) angle += 180;
          }
          cannon(angle,sqrt(dist2));
        }
      }
    } else {
/*
</PRE>El robot está solo. Disparar sin preocupación.<PRE>*/
      cannon(scan,range);
      scan -= 10;
    }
  }
}

}
</PRE>
      <P>Puedes encontrar el código fuente de <B>Platoon</B> en la 
      <a href="http://jrobots.sourceforge.net/downloads.shtml">página de downloads</a>. 
      <P>Por preguntas o comentarios, envía un <A href="mailto:boselli@uno.it">email</A>. 
      <HR>
      <P><FONT color=yellow>
      <a href="mailto:boselli@uno.it" name="Phalanax y Stinger"><B>Jrobot: Phalanx 
      y&nbsp; Stinger</B> - <FONT 
      size=-1>Autor: Leonardo 
      Boselli</FONT></a></FONT><a href="mailto:boselli@uno.it" name="Phalanax y Stinger">
      </a> 
      <P><B>Platoon</B> funciona bien en el modo por equipos (Team), pero 
      algunos robots con buenas técnicas de detección le ganan fácilmente en los 
      modos Single y Double, porque sus movimientos son fácilmente previsibles. 
      Para mejorar el comportamiento de 
      <B>Platoon</B>, he escrito <B>Phalanx</B> y <B>Stinger</B>. 
      <P>Los mejores robots usan el seguimiento de la velocidad del enemigo para 
      aumentar el daño causado por sus misiles. Esta técnica es útil cuando el 
      enemigo usa una velocidad constante, y facilita la estimación de la 
      ubicación del enemigo al final del vuelo del misil. Si el robot se mueve 
      hacia atrás y hacia adelante, los enemigos más inteligentes son 
      confundidos, pero los menos inteligentes tiene suerte, ya que sus disparos 
      no predictivos, pueden tener suerte e impactar al robot en los cambios de 
      dirección. Una mejor solución es seguir una ruta en zigzag como lo hace <B>Phalanx</B>. 
      <P><B>Stinger</B> usa la misma técnica de disparo de <B>Phalanx</B>, pero 
      tiene algoritmos de movimientos diferentes. Busca el enemigo más cercano y 
      lo sigue como una sombra. Cuando está realmente cerca (menos de 40 metros) 
      dispara misiles a una distancia de 45 metros, de tal manera de dañar al 
      enemigo sin dañarse a si mismo.<P>Ahora <B>Phalanx</B> combina las 5 
    principales técnicas de los robots más desarrollados. Las reglas que sigue 
    son: 
      <OL>
        <LI><B>No disparar a los amigos</B>: aplica a los modos Double y Team 
        <LI><B>Mantener alta velocidad y cambiar de dirección rápidamente</B>: 
        esto evita misiles disparados al lugar del escaneo<LI><B>Seguir una ruta 
        en zigzag</B>: esto evita misiles disparados por robots más inteligentes<LI><B>
        Correr en grupos para acumular poder de disparo</B>: un excelente valor 
        en el modo Team 
        <LI><B>Calcular tiempo de vuelo de los misiles y estimar correctamente 
        la posición futura del enemigo</B>: bueno si deseas golpear duro a 
        alguien</LI></OL>
      <P><B>Stinger</B> cambia las reglas 3 y 4 por: 
      <OL start=3>
        <LI><B>Seguir al enemigo más cercano muy de cerca</B>: esto confunde al 
        enemigo<LI><B>Dispara hacia el enemigo evitando daños propios</B>: bueno 
        si la distancia es menor que 40 metros</LI></OL>
      <P>Puedes encontrar el código fuente de <B>Phalanx</B> y <B>Stinger</B> en 
      la <a href="http://jrobots.sourceforge.net/downloads.shtml">página de downloads</a>. 
      <P>Por preguntas o comentarios, envía un <A href="mailto:boselli@uno.it">email</A>.

</FONT>
<!--------------------------------------------------->
<!-------- End of Text. No More changes! ------------>
<!--------------------------------------------------->


</td></tr></table>

 </TD></TR></TABLE>

  </TD></TR>

<!-------------------- FOOTER ---------------------->


<TR><TD>

<table border=1 bordercolor="black" cellpadding=5 cellspacing=0 bgcolor=78398D width=100%>
<tr><td align=center>
    <TABLE WIDTH=100% CELLPADDING=0 BORDER=0 CELLSPACING=0>
    <TR><TD width=50% ALIGN=LEFT>
<font color=white size=1 face=verdana,arial>For more information<BR>send an <A HREF="mailto:tetractys@uno.it">email</A> to<BR><A HREF="http://www.uno.it/utenti/tetractys/">TETRACTYS Software</A></FONT>
    </TD><TD ALIGN=RIGHT VALIGN=CENTER width=50%>
<font color=white size=1 face=verdana,arial>Copyright &copy; 1999-2005 <a href="mailto:boselli@uno.it">Leonardo Boselli</a><BR>All Rights Reserved. <a href="copyright.html">Legal Terms</a>.</FONT>
    </TD></TR>
    </TABLE>

</td></tr></table>


  </TD></TR> 
  </TABLE>
</BODY>
</HTML>

